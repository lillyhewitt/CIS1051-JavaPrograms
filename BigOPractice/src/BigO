import com.sun.source.tree.ArrayAccessTree;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class BigO {
    /*

    Big O Notation: when data/storgae is being doubled/incrementated

    costs when programming:
    time: order of magnitude that program runs
    space: ram, disc space, memory/space complexity
    energy

    O(n): worse case scenario for time (constant time)
    t(n) = O(n)

    Constant time algorithms: takes the same time disregarding amount of items it has to deal with
        examples: size method, get method, set method
        O(1)

    Linear time algorithms: grow at a linear rate as they get more items
        examples: contains method
        O(n)

    Quadratic algorithms: grows at a quadratic rate as they get more items
        examples: sorting/selection
        O(n^2)

    O(1): constant
    O(log n): logarithmic
    O(n): linear
    O(n log n): log-linear
    O(n^2): quadratic
    O(n^3): cubic
    O(2^n): expontential
        // any increase in input, doubles the runtime
    O(n!): factorial

     */

    // constant time algorithm
    public static <E> int howBig(ArrayList<E> list) {
        return list.size();
    }

    // linear time algorithm
    public static <E> boolean in(ArrayList list, E item) {
        for (int i = 0; i < list.size(); i++) {
            for (int j = 0; j < 10000; j++) {
                System.out.println("");
            }
            if(list.get(i).equals(item)) {
                return true;
            }
        }
        return false;
    }

    // linear time algorithm
    public static int sum(ArrayList<Integer> list) {
        int total = 0;
        for (int i = 0; i < list.size(); i++) {
            total += list.get(i); // O(1)
        }
        return total;
    }

    // quadratic time (double items, triple run time)
    public static <E> boolean allUnique(ArrayList<E> list) {
       //method 1
        for (int i = 0; i < list.size(); i++) { // O(n)
            for (int j = 0; j < list.size(); j++) { // O(n)
                if(list.get(i).equals(list.get(j))){ //O(1)
                    return false;
                }
            }
        }
        return true;

        //method 2
        //Set<E> set = new HashSet<>();
        //for(E item: list) {
        //    boolean couldAdd = set.add(item);
        //    if(couldAdd == false) {
        //        return false;
        //    }
        //}
    }

    /*
    sorting: smallest to largest selection/collection

    Bubble Sort: uses for loop to compare element in index to one before, makes sure smaller num is on the left
        keeps going through the list until every comparison is sorted
     */

    // can only compare same types (comparable)
    public static <T extends Comparable<T>> void bubbleSort(List<T> list) {
        //a.compareTo(b)
        // if a comes before b, returns negative
        // if a = b, returns 0
        // if comes after b, returns positive
        boolean swapped = true;
        while (swapped) {
            swapped = false;
            for (int i = 0; i < list.size() - 1; i++) {
                T left = list.get(i);
                T right = list.get(i + 1);
                if (left.compareTo(right) > 0) {
                    list.set(i, right);
                    list.set(i + 1, left);
                    swapped = true;
                }
            }
        }
    }

    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>();

        for (int i = 0; i < 10000; i++) {
            list.add(i);
        }


        //understanding time/ runtime
        long start = System.currentTimeMillis();

        howBig(list);
        in(list, -13);

        for (int i = 0; i < 100000; i++) {
            System.out.print("");
        }
        long end = System.currentTimeMillis();
        System.out.println(end - start);
    }
}
